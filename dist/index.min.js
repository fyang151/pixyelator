function convertToImageElement(e){switch(!0){case e instanceof HTMLImageElement:return e;case e instanceof Blob:return blobToImageElement(e);case"string"==typeof e&&e.startsWith("data:"):return dataURLToImageElement(e);case"string"==typeof e:return imageUrlToImageElement(e);case e instanceof ArrayBuffer:return arrayBufferToImageElement(e);default:throw new Error("Unsupported image type")}}function blobToImageElement(e){const t=URL.createObjectURL(e),a=document.createElement("img");return a.src=t,new Promise((e,n)=>{a.onload=()=>{URL.revokeObjectURL(t),e(a)},a.onerror=()=>{URL.revokeObjectURL(t),n(a)}})}function dataURLToImageElement(e){const t=new Image;return t.src=e,new Promise((e,a)=>{t.onload=()=>e(t),t.onerror=e=>a(e)})}function imageUrlToImageElement(e){const t=new Image;return t.crossOrigin="anonymous",t.src=e,new Promise((e,a)=>{t.onload=()=>e(t),t.onerror=()=>a(t)})}function arrayBufferToImageElement(e){return blobToImageElement(new Blob([e],{type:"image/png"}))}function canvasToBlob(e){return new Promise((t,a)=>{e.toBlob(e=>{e?t(e):a(new Error("Canvas to Blob conversion failed"))},"image/png")})}function canvasToDataURL(e){return e.toDataURL("image/png")}function canvasToArrayBuffer(e){return new Promise((t,a)=>{e.toBlob(e=>{e?t(e.arrayBuffer()):a(new Error("Canvas to Blob conversion failed"))})})}export class Pixyelator{constructor(e,t={}){this._imageElement=e,this._width=e.naturalWidth,this._height=e.naturalHeight,this._canvas=t.targetCanvas||document.createElement("canvas"),this._isDisposed=!1}static async fromImage(e,t={}){const a=await convertToImageElement(e);if(!a)throw new Error("Failed to load image");if(0===a.naturalWidth||0===a.naturalHeight)throw new Error("Invalid image dimensions");return new Pixyelator(a,t)}pixelate(e,t,a={}){if(this._isDisposed)throw new Error("Cannot operate on disposed Pixyelator instance");if(!Number.isInteger(e)||!Number.isInteger(t)||e<=0||t<=0)throw new Error("Pixel dimensions must be positive integers");if(e>this._width||t>this._height)throw new Error("Pixel dimensions cannot exceed image dimensions");const n=this._pixelateElementToCanvas(e,t,a);return Object.assign(n,{toBlob:async()=>(await n,this.toBlob()),toCanvas:async()=>(await n,this.toCanvas()),toDataURL:async()=>(await n,this.toDataURL()),toArrayBuffer:async()=>(await n,this.toArrayBuffer())})}async _pixelateElementToCanvas(e,t,a={}){const n=this._canvas;n.width=this._width,n.height=this._height;const r=n.getContext("2d"),o=a.grayscale||!1,s=await createImageBitmap(this._imageElement),i=await new Promise((a,n)=>{const r=new Worker(new URL("rgbaWorker.min.js",import.meta.url));r.onmessage=e=>{r.terminate(),e.data.success?a(e.data.bitmap):n(new Error(e.data.error))},r.onerror=e=>{r.terminate(),n(e)},r.postMessage([s,e,t,o],[s])});r.imageSmoothingEnabled=!1,r.drawImage(i,0,0,this._width,this._height),i.close()}toCanvas(){if(this._isDisposed)throw new Error("Cannot operate on disposed Pixyelator instance");return this._canvas}async toBlob(){if(this._isDisposed)throw new Error("Cannot operate on disposed Pixyelator instance");return canvasToBlob(this._canvas)}toDataURL(){if(this._isDisposed)throw new Error("Cannot operate on disposed Pixyelator instance");return canvasToDataURL(this._canvas)}async toArrayBuffer(){if(this._isDisposed)throw new Error("Cannot operate on disposed Pixyelator instance");return canvasToArrayBuffer(this._canvas)}dispose(){this._isDisposed||(this._imageElement=null,this._canvas=null,this._isDisposed=!0)}}